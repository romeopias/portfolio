
      const trigger = document.getElementById(&#39;scanTrigger&#39;);
        const secretModal = document.getElementById(&#39;secretModal&#39;);
        const mainCard = document.getElementById(&#39;mainCard&#39;);
        let pressTimer;
        const startPress = (e) =&gt; { if(e.cancelable) e.preventDefault(); trigger.classList.add(&#39;pressing&#39;); pressTimer = setTimeout(() =&gt; { openSecret(); }, 3000); };
        const cancelPress = () =&gt; { trigger.classList.remove(&#39;pressing&#39;); clearTimeout(pressTimer); };
        trigger.addEventListener(&#39;touchstart&#39;, startPress, {passive: false});
        trigger.addEventListener(&#39;touchend&#39;, cancelPress);
        trigger.addEventListener(&#39;touchcancel&#39;, cancelPress);
        trigger.addEventListener(&#39;mousedown&#39;, startPress);
        trigger.addEventListener(&#39;mouseup&#39;, cancelPress);
        trigger.addEventListener(&#39;mouseleave&#39;, cancelPress);
        function openSecret() { mainCard.style.opacity = &#39;0&#39;; setTimeout(() =&gt; { secretModal.classList.add(&#39;active&#39;); createHearts(); }, 500); }
        function closeSecret() { secretModal.classList.remove(&#39;active&#39;); setTimeout(() =&gt; { mainCard.style.opacity = &#39;1&#39;; }, 500); }
        function createHearts() { setInterval(() =&gt; { if(secretModal.classList.contains(&#39;active&#39;)) { const heart = document.createElement(&#39;div&#39;); heart.classList.add(&#39;heart&#39;); heart.innerHTML = &#39;❤️&#39;; heart.style.left = Math.random() * 100 + &#34;vw&#34;; heart.style.fontSize = Math.random() * 20 + 10 + &#34;px&#34;; heart.style.animationDuration = Math.random() * 2 + 3 + &#34;s&#34;; document.getElementById(&#39;secretModal&#39;).appendChild(heart); setTimeout(() =&gt; { heart.remove(); }, 5000); } }, 300); }
        let isMulticolor = false;
        function toggleEffect() { const btn = document.querySelector(&#39;.effect-btn&#39;); isMulticolor = !isMulticolor; if (isMulticolor) { btn.innerHTML = &#39;&lt;i class=&#34;fas fa-magic&#34;&gt;&lt;/i&gt; MAGIC ON&#39;; btn.style.background = &#34;#ff00de&#34;; btn.style.color = &#34;#fff&#34;; btn.style.borderColor = &#34;#ff00de&#34;; } else { btn.innerHTML = &#39;&lt;i class=&#34;fas fa-magic&#34;&gt;&lt;/i&gt; MAGIC OFF&#39;; btn.style.background = &#34;rgba(255, 255, 255, 0.1)&#34;; btn.style.color = &#34;#0ff&#34;; btn.style.borderColor = &#34;#0ff&#34;; } }
        const canvas = document.getElementById(&#34;particles&#34;); const ctx = canvas.getContext(&#34;2d&#34;); canvas.width = window.innerWidth; canvas.height = window.innerHeight; let particlesArray; let mouse = { x: null, y: null, radius: (canvas.height/80) * (canvas.width/80) }
        window.addEventListener(&#39;mousemove&#39;, (event) =&gt; { mouse.x = event.x; mouse.y = event.y; }); class Particle { constructor(x, y, directionX, directionY, size, color) { this.x = x; this.y = y; this.directionX = directionX; this.directionY = directionY; this.size = size; this.randomColor = &#39;hsl(&#39; + Math.random() * 360 + &#39;, 100%, 50%)&#39;; } draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false); if(isMulticolor) { ctx.fillStyle = this.randomColor; } else { ctx.fillStyle = &#39;#00ffff&#39;; } ctx.fill(); } update() { if (this.x &gt; canvas.width || this.x &lt; 0) { this.directionX = -this.directionX; } if (this.y &gt; canvas.height || this.y &lt; 0) { this.directionY = -this.directionY; } let dx = mouse.x - this.x; let dy = mouse.y - this.y; let distance = Math.sqrt(dx*dx + dy*dy); if (distance &lt; mouse.radius + this.size){ if (mouse.x &lt; this.x &amp;&amp; this.x &lt; canvas.width - this.size * 10) { this.x += 3; } if (mouse.x &gt; this.x &amp;&amp; this.x &gt; this.size * 10) { this.x -= 3; } if (mouse.y &lt; this.y &amp;&amp; this.y &lt; canvas.height - this.size * 10) { this.y += 3; } if (mouse.y &gt; this.y &amp;&amp; this.y &gt; this.size * 10) { this.y -= 3; } } this.x += this.directionX; this.y += this.directionY; this.draw(); } } function init() { particlesArray = []; let numberOfParticles = (canvas.height * canvas.width) / 9000; for (let i = 0; i &lt; numberOfParticles; i++) { let size = (Math.random() * 2) + 1; let x = (Math.random() * ((innerWidth - size * 2) - (size * 2)) + size * 2); let y = (Math.random() * ((innerHeight - size * 2) - (size * 2)) + size * 2); let directionX = (Math.random() * 2) - 1; let directionY = (Math.random() * 2) - 1; let color = &#39;#00ffff&#39;; particlesArray.push(new Particle(x, y, directionX, directionY, size, color)); } } function connect() { let opacityValue = 1; for (let a = 0; a &lt; particlesArray.length; a++) { for (let b = a; b &lt; particlesArray.length; b++) { let distance = ((particlesArray[a].x - particlesArray[b].x) * (particlesArray[a].x - particlesArray[b].x)) + ((particlesArray[a].y - particlesArray[b].y) * (particlesArray[a].y - particlesArray[b].y)); if (distance &lt; (canvas.width/7) * (canvas.height/7)) { opacityValue = 1 - (distance/20000); if(isMulticolor) { ctx.strokeStyle = &#39;rgba(&#39; + Math.random()*255 + &#39;,&#39; + Math.random()*255 + &#39;,&#39; + Math.random()*255 + &#39;,&#39; + opacityValue + &#39;)&#39;; } else { ctx.strokeStyle = &#39;rgba(0, 255, 255,&#39; + opacityValue + &#39;)&#39;; } ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(particlesArray[a].x, particlesArray[a].y); ctx.lineTo(particlesArray[b].x, particlesArray[b].y); ctx.stroke(); } } } } function animate() { requestAnimationFrame(animate); ctx.clearRect(0, 0, innerWidth, innerHeight); for (let i = 0; i &lt; particlesArray.length; i++) { particlesArray[i].update(); } connect(); } window.addEventListener(&#39;resize&#39;, function(){ canvas.width = innerWidth; canvas.height = innerHeight; mouse.radius = ((canvas.height/80) * (canvas.height/80)); init(); }); init(); animate();

